<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN" "" >
<html>
	<head>
		<!--
		Copyright (c) 2007 Peter Suggitt
		-->
	</head>
	<body bgcolor="white">
		
		<p>This top level package contains example code for the structural patterns, ie
			those patterns that are used to form structured designs for differing problems.
			This package contains the following specific patterns.
			<ul>
				<li>Adapter pattern - this pattern is similar to the Decorator pattern in
					that it is about the wrapping of objects with others and thus changing
					their interface. The Decorator pattern wraps objects to extend their
					functionality whereas the adapter pattern wraps an object to hide its
					interface and expose a new (more desirable interface). This pattern is
					all about creating an object interface and then mapping it to another
					objects interface.</li>
				<li>Bridge pattern - </li>
				<li>Composite pattern - in this pattern we create objects in a tree
					structure with nodes and leaves. In doing this all objects (and
					compositions of objects)in the tree can be treated equally irrelevant
					of the placement within the tree. IN othr words this allows us to treat a
					single object or a tree of objects in exactly the same recursive manner.
					Some good examples of this would be XML trees and directory
					structures.</li>
				<li>Decorator pattern - in this pattern we 'wrap' up an object with another
					instance of the same interface or abstract class. This is used when
					inheritance is too great a job (eg if there are too many posibilities)
					and thus an element of wrapping of an object is more powerfull than
					inheritance (can only inherit from one class). So for example if we have
					an object deriving from an interface containing a method called foo(),
					we then create a wrapper object that also derives from that object that
					will first call the inner foo() andthen its local impl of foo().</li>
				<li>Facade pattern - in this pattern we create a class that will simplify a
					collection of interfaces into a consolidated and more simple one. The
					existing interfaces remain but a new, more simple one also exists to
					remove some of the complexities from the existing interfaces. The most
					common implementation of this would be to put a high level interface
					above an entire subsystem so that there is a common client interface to
					that functionality (and thus an entire subsystem can be replaced more
					easily).</li>
				<li>Flyweight pattern - </li>
				<li>Proxy pattern - the core of this pattern is to create an object
					controller and put this in the execution path of a client, thus a client
					does not interact with the intended object and instead interacts with
					the controller (or proxy). Essentially a proxy will controll access to
					another object, and this is why it must share the same underlying
					interface. Some obvious uses are: remote proxy, where the proxy
					manages the remote communication (RMI); virtual proxy, where the
					proxy manages the construction of an object where the object is
					expensive to create (or takes a while due to network latency); dynamic
					proxy, where the proxy involves itself with providing a layer of
					functionality (typically security) to an execution stack; firewall
					proxy; smart reference proxy (smart pointers); caching proxy,
					providing temporary results for expensive operations;
					synchronisation proxy, providing mutex access to objects in a
					multi-threaded environment; facade proxy (doing what the facade
					pattern does); </li>
			</ul> </p>
		
		<h2>Package Specification</h2>
		
		<h2>Related Documentation</h2>
		
		<!-- Put @see and @since tags down here. -->
	</body>
</html>
